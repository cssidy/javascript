<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>


<script>

    // objects are containers for properties, each of which has a name and value

    var cassidy = new Object();
    cassidy.living = true;
    cassidy.age = 25;
    cassidy.gender = 'female';
    cassidy.getGender = function(){return cassidy.gender;};

    console.log(cassidy.getGender());

</script>


<script>

    var myObject = new Object();
    myObject['0'] = 'f';
    myObject['1'] = 'o';
    myObject['2'] = 'o';

    console.log(myObject);

    var myString = new String('foo');

    console.log(myString);

</script>


<script>

    var Person = function(living, age, gender) {
        this.living = living;
        this.age = age;
        this.gender = gender;
        this.getGender = function() {return this.gender;};
    }

    var brooke = new Person(true, 25, 'lizard');

    console.log(brooke); // logs the internal properties and values
    console.log(typeof brooke); // logs 'object'
    console.log(brooke.constructor); // logs the Person() function

</script>

<script>

    var myNumber = new Number(23);
    var myNumberLiteral = 23; // primitive number value, not an object, 'irreducible' values
    var myString = new String('male');
    var myBoolean = new Boolean(false);
    var myObject = new Object();
    var myArray = new Array('foo', 'bar');
    var myFunction = new Function("x", "y", "return x*y");
    var myDate = new Date();
    var myRegExp = new RegExp('\bt[a-z]+a\b');
    var myError = new Error('Crap!');


    console.log(myNumber.constructor);
    console.log(myNumberLiteral)
    console.log(myString.constructor);
    console.log(myBoolean.constructor);
    console.log(myObject.constructor);
    console.log(myArray.constructor);
    console.log(myFunction.constructor);
    console.log(myDate.constructor);
    console.log(myRegExp.constructor);
    console.log(myError.constructor);

</script>


<script>

    var myString = 'foo';
    var myStringCopy = myString;

    var myString = null;
    // the original value for myString is copied to myStringCopy, and retains that after myString has been altered
    console.log(myString, myStringCopy);

</script>


<script>

    var price1= 10;
    var price2 = 10;
    var price3 = new Number('10'); // complex numeric object because 'new' was used
    var price4 = price3;

    console.log(price1 == price2); // true, both primitive values == 10
    console.log(price1 == price3); // false, price1 is primitive price3 is complex
    console.log(price3 == price4); // true, both complex values == 10

</script>


<script>

    var object = {
        myString: 'string',
        myNumber: 10,
        myBoolean: false,
        myNull: null,
        myUndefined: undefined
    };

    console.log(object);

    var array = ['string', 10, false, null, undefined];

    console.log(array);

</script>


<script>
    // unlike primitive values that copy a value as it is at one point in time, objects (complex values) copy the reference
    // and will update their value as it is changed
    var myObject = {};
    var copyOfMyObject = myObject;
    myObject.cassidy = 'happy';

    console.log(myObject, copyOfMyObject);

</script>

<script>

    var objectFoo = {same: 'same'};
    var objectBar = {same: 'same'};
    console.log(objectFoo == objectBar); // false, two variables containing identical objects are not equal unless they point at the same object

    var objectA = {foo: 'meow'};
    var objectB = objectA;
    console.log(objectA == objectB); // true, points at same object

    var myNull = null;
    console.log(typeof myNull); // logs object !?!?

    var myNumber = new Number(23);
    console.log(typeof myNumber); // logs object

    var otherNumber = 23;
    console.log(typeof otherNumber); // logs number

</script>


</body>
</html>